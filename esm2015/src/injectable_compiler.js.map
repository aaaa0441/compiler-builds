{"version":3,"file":"injectable_compiler.js","sourceRoot":"","sources":["../../../../packages/compiler/src/injectable_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from './aot/static_symbol';\nimport {CompileInjectableMetadata, CompileNgModuleMetadata, CompileProviderMetadata, identifierName} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {InjectFlags, NodeFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {convertValueToOutputAst} from './output/value_util';\nimport {typeSourceSpan} from './parse_util';\nimport {NgModuleProviderAnalyzer} from './provider_analyzer';\nimport {OutputContext} from './util';\nimport {componentFactoryResolverProviderDef, depDef, providerDef} from './view_compiler/provider_compiler';\n\ntype MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\ntype MapLiteral = MapEntry[];\n\nfunction mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport class InjectableCompiler {\n  private tokenInjector: StaticSymbol;\n  constructor(private reflector: CompileReflector, private alwaysGenerateDef: boolean) {\n    this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n  }\n\n  private depsArray(deps: any[], ctx: OutputContext): o.Expression[] {\n    return deps.map(dep => {\n      let token = dep;\n      let args = [token];\n      let flags: InjectFlags = InjectFlags.Default;\n      if (Array.isArray(dep)) {\n        for (let i = 0; i < dep.length; i++) {\n          const v = dep[i];\n          if (v) {\n            if (v.ngMetadataName === 'Optional') {\n              flags |= InjectFlags.Optional;\n            } else if (v.ngMetadataName === 'SkipSelf') {\n              flags |= InjectFlags.SkipSelf;\n            } else if (v.ngMetadataName === 'Self') {\n              flags |= InjectFlags.Self;\n            } else if (v.ngMetadataName === 'Inject') {\n              token = v.token;\n            } else {\n              token = v;\n            }\n          }\n        }\n      }\n\n      let tokenExpr: o.Expression;\n      if (typeof token === 'string') {\n        tokenExpr = o.literal(token);\n      } else if (token === this.tokenInjector) {\n        tokenExpr = o.importExpr(Identifiers.INJECTOR);\n      } else {\n        tokenExpr = ctx.importExpr(token);\n      }\n\n      if (flags !== InjectFlags.Default) {\n        args = [tokenExpr, o.literal(flags)];\n      } else {\n        args = [tokenExpr];\n      }\n      return o.importExpr(Identifiers.inject).callFn(args);\n    });\n  }\n\n  factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let retValue: o.Expression;\n    if (injectable.useExisting) {\n      retValue = o.importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n    } else if (injectable.useFactory) {\n      const deps = injectable.deps || [];\n      if (deps.length > 0) {\n        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n      } else {\n        return ctx.importExpr(injectable.useFactory);\n      }\n    } else if (injectable.useValue) {\n      retValue = convertValueToOutputAst(ctx, injectable.useValue);\n    } else {\n      const clazz = injectable.useClass || injectable.symbol;\n      const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n      retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n    }\n    return o.fn(\n        [], [new o.ReturnStatement(retValue)], undefined, undefined,\n        injectable.symbol.name + '_Factory');\n  }\n\n  injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let providedIn: o.Expression = o.NULL_EXPR;\n    if (injectable.providedIn !== undefined) {\n      if (injectable.providedIn === null) {\n        providedIn = o.NULL_EXPR;\n      } else if (typeof injectable.providedIn === 'string') {\n        providedIn = o.literal(injectable.providedIn);\n      } else {\n        providedIn = ctx.importExpr(injectable.providedIn);\n      }\n    }\n    const def: MapLiteral = [\n      mapEntry('factory', this.factoryFor(injectable, ctx)),\n      mapEntry('token', ctx.importExpr(injectable.type.reference)),\n      mapEntry('providedIn', providedIn),\n    ];\n    return o.importExpr(Identifiers.defineInjectable).callFn([o.literalMap(def)]);\n  }\n\n  compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void {\n    if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n      const className = identifierName(injectable.type) !;\n      const clazz = new o.ClassStmt(\n          className, null,\n          [\n            new o.ClassField(\n                'ngInjectableDef', o.INFERRED_TYPE, [o.StmtModifier.Static],\n                this.injectableDef(injectable, ctx)),\n          ],\n          [], new o.ClassMethod(null, [], []), []);\n      ctx.statements.push(clazz);\n    }\n  }\n}\n"]}