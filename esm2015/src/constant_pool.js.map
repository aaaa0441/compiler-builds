{"version":3,"file":"constant_pool.js","sourceRoot":"","sources":["../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\n// Closure variables holding messages must be named `MSG_[A-Z0-9]+`\nconst TRANSLATION_PREFIX = 'MSG_';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Closure uses `goog.getMsg(message)` to lookup translations\n */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  shared: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private translations = new Map<string, o.Expression>();\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  // Generates closure specific code for translation.\n  //\n  // ```\n  // /**\n  //  * @desc description?\n  //  * @meaning meaning?\n  //  */\n  // const MSG_XYZ = goog.getMsg('message');\n  // ```\n  getTranslation(message: string, meta: {description?: string, meaning?: string}): o.Expression {\n    // The identity of an i18n message depends on the message and its meaning\n    const key = meta.meaning ? `${message}\\u0000\\u0000${meta.meaning}` : message;\n\n    const exp = this.translations.get(key);\n\n    if (exp) {\n      return exp;\n    }\n\n    const docStmt = i18nMetaToDocStmt(meta);\n    if (docStmt) {\n      this.statements.push(docStmt);\n    }\n\n    // Call closure to get the translation\n    const variable = o.variable(this.freshTranslationName());\n    const fnCall = o.variable(GOOG_GET_MSG).callFn([o.literal(message)]);\n    const msgStmt = variable.set(fnCall).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]);\n    this.statements.push(msgStmt);\n\n    this.translations.set(key, variable);\n    return variable;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ngComponentDef';\n      case DefinitionKind.Directive:\n        return 'ngDirectiveDef';\n      case DefinitionKind.Injector:\n        return 'ngInjectorDef';\n      case DefinitionKind.Pipe:\n        return 'ngPipeDef';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private freshTranslationName(): string {\n    return this.uniqueName(TRANSLATION_PREFIX).toUpperCase();\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitReadVarExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n}\n\nfunction invalid<T>(arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\n// Converts i18n meta informations for a message (description, meaning) to a JsDoc statement\n// formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta: {description?: string, id?: string, meaning?: string}):\n    o.JSDocCommentStmt|null {\n  const tags: o.JSDocTag[] = [];\n\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  }\n\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n\n  return tags.length == 0 ? null : new o.JSDocCommentStmt(tags);\n}\n"]}