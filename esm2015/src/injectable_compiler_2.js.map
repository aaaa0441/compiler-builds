{"version":3,"file":"injectable_compiler_2.js","sourceRoot":"","sources":["../../../../packages/compiler/src/injectable_compiler_2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from './core';\nimport * as o from './output/output_ast';\nimport {Identifiers} from './render3/r3_identifiers';\n\n\ntype MapEntry = {\n  key: string; quoted: boolean; value: o.Expression;\n};\n\nfunction mapToMapExpression(map: {[key: string]: o.Expression}): o.LiteralMapExpr {\n  const result = Object.keys(map).map(key => ({key, value: map[key], quoted: false}));\n  return o.literalMap(result);\n}\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport interface IvyInjectableDep {\n  token: o.Expression;\n  optional: boolean;\n  self: boolean;\n  skipSelf: boolean;\n}\n\nexport interface IvyInjectableMetadata {\n  name: string;\n  type: o.Expression;\n  providedIn: o.Expression;\n  useType?: IvyInjectableDep[];\n  useClass?: o.Expression;\n  useFactory?: {factory: o.Expression; deps: IvyInjectableDep[];};\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n}\n\nexport function compileIvyInjectable(meta: IvyInjectableMetadata): InjectableDef {\n  let ret: o.Expression = o.NULL_EXPR;\n  if (meta.useType !== undefined) {\n    const args = meta.useType.map(dep => injectDep(dep));\n    ret = new o.InstantiateExpr(meta.type, args);\n  } else if (meta.useClass !== undefined) {\n    const factory =\n        new o.ReadPropExpr(new o.ReadPropExpr(meta.useClass, 'ngInjectableDef'), 'factory');\n    ret = new o.InvokeFunctionExpr(factory, []);\n  } else if (meta.useValue !== undefined) {\n    ret = meta.useValue;\n  } else if (meta.useExisting !== undefined) {\n    ret = o.importExpr(Identifiers.inject).callFn([meta.useExisting]);\n  } else if (meta.useFactory !== undefined) {\n    const args = meta.useFactory.deps.map(dep => injectDep(dep));\n    ret = new o.InvokeFunctionExpr(meta.useFactory.factory, args);\n  } else {\n    throw new Error('No instructions for injectable compiler!');\n  }\n\n  const token = meta.type;\n  const providedIn = meta.providedIn;\n  const factory =\n      o.fn([], [new o.ReturnStatement(ret)], undefined, undefined, `${meta.name}_Factory`);\n\n  const expression = o.importExpr({\n                        moduleName: '@angular/core',\n                        name: 'defineInjectable',\n                      }).callFn([mapToMapExpression({token, factory, providedIn})]);\n  const type = new o.ExpressionType(o.importExpr(\n      {\n        moduleName: '@angular/core',\n        name: 'InjectableDef',\n      },\n      [new o.ExpressionType(meta.type)]));\n\n  return {\n      expression, type,\n  };\n}\n\nfunction injectDep(dep: IvyInjectableDep): o.Expression {\n  const defaultValue = dep.optional ? o.NULL_EXPR : o.literal(undefined);\n  const flags = o.literal(\n      InjectFlags.Default | (dep.self && InjectFlags.Self || 0) |\n      (dep.skipSelf && InjectFlags.SkipSelf || 0));\n  if (!dep.optional && !dep.skipSelf && !dep.self) {\n    return o.importExpr(Identifiers.inject).callFn([dep.token]);\n  } else {\n    return o.importExpr(Identifiers.inject).callFn([\n      dep.token,\n      defaultValue,\n      flags,\n    ]);\n  }\n}\n"]}