{"version":3,"file":"static_symbol_resolver.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName} from './util';\n\nconst DTS = /\\.d\\.ts$/;\nconst TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n\nexport class ResolvedStaticSymbol {\n  constructor(public symbol: StaticSymbol, public metadata: any) {}\n}\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined;\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n\n  /**\n   * Get a file suitable for display to the user that should be relative to the project directory\n   * or the current directory.\n   */\n  getOutputName(filePath: string): string;\n}\n\nconst SUPPORTED_SCHEMA_VERSION = 4;\n\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\n  private metadataCache = new Map<string, {[key: string]: any}>();\n  // Note: this will only contain StaticSymbols without members!\n  private resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\n  private resolvedFilePaths = new Set<string>();\n  // Note: this will only contain StaticSymbols without members!\n  private importAs = new Map<StaticSymbol, StaticSymbol>();\n  private symbolResourcePaths = new Map<StaticSymbol, string>();\n  private symbolFromFile = new Map<string, StaticSymbol[]>();\n  private knownFileNameToModuleNames = new Map<string, string>();\n\n  constructor(\n      private host: StaticSymbolResolverHost, private staticSymbolCache: StaticSymbolCache,\n      private summaryResolver: SummaryResolver<StaticSymbol>,\n      private errorRecorder?: (error: any, fileName?: string) => void) {}\n\n  resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol) !;\n    }\n    // Note: always ask for a summary first,\n    // as we might have read shallow metadata via a .d.ts file\n    // for the symbol.\n    const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol) !;\n    if (resultFromSummary) {\n      return resultFromSummary;\n    }\n    const resultFromCache = this.resolvedSymbols.get(staticSymbol);\n    if (resultFromCache) {\n      return resultFromCache;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    return this.resolvedSymbols.get(staticSymbol) !;\n  }\n\n  /**\n   * getImportAs produces a symbol that can be used to import the given symbol.\n   * The import might be different than the symbol if the symbol is exported from\n   * a library with a summary; in which case we want to import the symbol from the\n   * ngfactory re-export instead of directly to avoid introducing a direct dependency\n   * on an otherwise indirect dependency.\n   *\n   * @param staticSymbol the symbol for which to generate a import symbol\n   */\n  getImportAs(staticSymbol: StaticSymbol, useSummaries: boolean = true): StaticSymbol|null {\n    if (staticSymbol.members.length) {\n      const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n    if (summarizedFileName !== staticSymbol.filePath) {\n      const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n      const baseSymbol =\n          this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(\n              summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name),\n              baseSymbol.members) :\n          null;\n    }\n    let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n    if (!result) {\n      result = this.importAs.get(staticSymbol) !;\n    }\n    return result;\n  }\n\n  /**\n   * getResourcePath produces the path to the original location of the symbol and should\n   * be used to determine the relative location of resource references recorded in\n   * symbol metadata.\n   */\n  getResourcePath(staticSymbol: StaticSymbol): string {\n    return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n  }\n\n  /**\n   * getTypeArity returns the number of generic type parameters the given symbol\n   * has. If the symbol is not a type the result is null.\n   */\n  getTypeArity(staticSymbol: StaticSymbol): number|null {\n    // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isGeneratedFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n\n  getKnownModuleName(filePath: string): string|null {\n    return this.knownFileNameToModuleNames.get(filePath) || null;\n  }\n\n  recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    this.importAs.set(sourceSymbol, targetSymbol);\n  }\n\n  recordModuleNameForFileName(fileName: string, moduleName: string) {\n    this.knownFileNameToModuleNames.set(fileName, moduleName);\n  }\n\n  /**\n   * Invalidate all information derived from the given file.\n   *\n   * @param fileName the file to invalidate\n   */\n  invalidateFile(fileName: string) {\n    this.metadataCache.delete(fileName);\n    this.resolvedFilePaths.delete(fileName);\n    const symbols = this.symbolFromFile.get(fileName);\n    if (symbols) {\n      this.symbolFromFile.delete(fileName);\n      for (const symbol of symbols) {\n        this.resolvedSymbols.delete(symbol);\n        this.importAs.delete(symbol);\n        this.symbolResourcePaths.delete(symbol);\n      }\n    }\n  }\n\n  /* @internal */\n  ignoreErrorsFor<T>(cb: () => T) {\n    const recorder = this.errorRecorder;\n    this.errorRecorder = () => {};\n    try {\n      return cb();\n    } finally {\n      this.errorRecorder = recorder;\n    }\n  }\n\n  private _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const members = staticSymbol.members;\n    const baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let value = baseMetadata;\n      for (let i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n\n  private _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n\n  /**\n   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n   *\n   * @param declarationFile the absolute path of the file where the symbol is declared\n   * @param name the name of the type.\n   * @param members a symbol for a static member of the named type\n   */\n  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n\n  /**\n   * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n   * metadata.\n   *\n   * @param filePath the absolute path to examine for decorators.\n   * @returns true if any class in the file has a decorator.\n   */\n  hasDecorators(filePath: string): boolean {\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      return Object.keys(metadata['metadata']).some((metadataKey) => {\n        const entry = metadata['metadata'][metadataKey];\n        return entry && entry.__symbolic === 'class' && entry.decorators;\n      });\n    }\n    return false;\n  }\n\n  getSymbolsOf(filePath: string): StaticSymbol[] {\n    const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n    if (summarySymbols) {\n      return summarySymbols;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n    this._createSymbolsOf(filePath);\n    const metadataSymbols: StaticSymbol[] = [];\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        metadataSymbols.push(resolvedSymbol.symbol);\n      }\n    });\n    return metadataSymbols;\n  }\n\n  private _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['importAs']) {\n      // Index bundle indices should use the importAs module name defined\n      // in the bundle.\n      this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n    }\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n\n    // handle the actual metadata. Has to be after the exports\n    // as there migth be collisions in the names, and we want the symbols\n    // of the current module to win ofter reexports.\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      const origins: {[index: string]: string} = metadata['origins'] || {};\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const symbolMeta = metadata['metadata'][metadataKey];\n        const name = unescapeIdentifier(metadataKey);\n\n        const symbol = this.getStaticSymbol(filePath, name);\n\n        const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n        if (origin) {\n          // If the symbol is from a bundled index, use the declaration location of the\n          // symbol so relative references (such as './my.html') will be calculated\n          // correctly.\n          const originFilePath = this.resolveModule(origin, filePath);\n          if (!originFilePath) {\n            this.reportError(\n                new Error(`Couldn't resolve original symbol for ${origin} from ${filePath}`));\n          } else {\n            this.symbolResourcePaths.set(symbol, originFilePath);\n          }\n        }\n        resolvedSymbols.push(\n            this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n      });\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n    this.symbolFromFile.set(filePath, resolvedSymbols.map(resolvedSymbol => resolvedSymbol.symbol));\n  }\n\n  private createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelPath: string, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    // For classes that don't have Angular summaries / metadata,\n    // we only keep their arity, but nothing else\n    // (e.g. their constructor parameters).\n    // We do this to prevent introducing deep imports\n    // as we didn't generate .ngfactory.ts files with proper reexports.\n    const isTsFile = TS.test(sourceSymbol.filePath);\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n        metadata['__symbolic'] === 'class') {\n      const transformedMeta = {__symbolic: 'class', arity: metadata.arity};\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n\n    let _originalFileMemo: string|undefined;\n    const getOriginalName: () => string = () => {\n      if (!_originalFileMemo) {\n        // Guess what hte original file name is from the reference. If it has a `.d.ts` extension\n        // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n        // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n        // location as it is not important to finding the file.\n        _originalFileMemo =\n            this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n                                        .replace(/^.*node_modules[/\\\\]/, ''));\n      }\n      return _originalFileMemo;\n    };\n\n    const self = this;\n\n    class ReferenceTransformer extends ValueTransformer {\n      visitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const module = map['module'];\n          const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath) !;\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`,\n                line: map.line,\n                character: map.character,\n                fileName: getOriginalName()\n              };\n            }\n            return {\n              __symbolic: 'resolved',\n              symbol: self.getStaticSymbol(filePath, name),\n              line: map.line,\n              character: map.character,\n              fileName: getOriginalName()\n            };\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(topLevelPath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else if (symbolic === 'error') {\n          return {...map, fileName: getOriginalName()};\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n    if (unwrappedTransformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n\n  private createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n        this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n\n  private reportError(error: Error, context?: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n\n  /**\n   * @param module an absolute path to a module file.\n   */\n  private getModuleMetadata(module: string): {[key: string]: any} {\n    let moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md && md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage));\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n\n\n  getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ' relative to ' +\n            containingFile : ''}`));\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n\n  private resolveModule(module: string, containingFile?: string): string|null {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch (e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(e, undefined, containingFile);\n    }\n    return null;\n  }\n}\n\n// Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n\nexport function unwrapResolvedMetadata(metadata: any): any {\n  if (metadata && metadata.__symbolic === 'resolved') {\n    return metadata.symbol;\n  }\n  return metadata;\n}"]}