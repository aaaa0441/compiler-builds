{"version":3,"file":"lexer.js","sourceRoot":"","sources":["../../../../../packages/compiler/src/ml_parser/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation_config';\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from './tags';\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(public type: TokenType, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(public tokens: Token[], public errors: TokenError[]) {}\n}\n\nexport function tokenize(\n    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,\n    tokenizeExpansionForms: boolean = false,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): TokenizeResult {\n  return new _Tokenizer(\n             new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms,\n             interpolationConfig)\n      .tokenize();\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nclass _ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See http://www.w3.org/TR/html51/syntax.html#writing\nclass _Tokenizer {\n  private _input: string;\n  private _length: number;\n  // Note: this is always lowercase!\n  private _peek: number = -1;\n  private _nextPeek: number = -1;\n  private _index: number = -1;\n  private _line: number = 0;\n  private _column: number = -1;\n  private _currentTokenStart: ParseLocation;\n  private _currentTokenType: TokenType;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation: boolean = false;\n\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n\n  /**\n   * @param _file The html source\n   * @param _getTagDefinition\n   * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n   * @param _interpolationConfig\n   */\n  constructor(\n      private _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,\n      private _tokenizeIcu: boolean,\n      private _interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    this._input = _file.content;\n    this._length = _file.content.length;\n    this._advance();\n  }\n\n  private _processCarriageReturns(content: string): string {\n    // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): TokenizeResult {\n    while (this._peek !== chars.$EOF) {\n      const start = this._getLocation();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        if (e instanceof _ControlFlowError) {\n          this.errors.push(e.error);\n        } else {\n          throw e;\n        }\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n    return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._peek === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getLocation(): ParseLocation {\n    return new ParseLocation(this._file, this._index, this._line, this._column);\n  }\n\n  private _getSpan(\n      start: ParseLocation = this._getLocation(),\n      end: ParseLocation = this._getLocation()): ParseSourceSpan {\n    return new ParseSourceSpan(start, end);\n  }\n\n  private _beginToken(type: TokenType, start: ParseLocation = this._getLocation()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end: ParseLocation = this._getLocation()): Token {\n    const token =\n        new Token(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n    this.tokens.push(token);\n    this._currentTokenStart = null !;\n    this._currentTokenType = null !;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): _ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null !;\n    this._currentTokenType = null !;\n    return new _ControlFlowError(error);\n  }\n\n  private _advance() {\n    if (this._index >= this._length) {\n      throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());\n    }\n    if (this._peek === chars.$LF) {\n      this._line++;\n      this._column = 0;\n    } else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {\n      this._column++;\n    }\n    this._index++;\n    this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);\n    this._nextPeek =\n        this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._peek === charCode) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._getLocation();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._index + len > this._length) {\n      return false;\n    }\n    const initialPosition = this._savePosition();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._restorePosition(initialPosition);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._getLocation();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._peek)) {\n      this._advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._getLocation();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._index - start.offset < len) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._peek !== char) {\n      this._advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._peek === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      const index = this._index;\n      this._advance();\n      return this._input[index];\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._getLocation();\n    this._advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const numberStart = this._getLocation().offset;\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._peek != chars.$SEMICOLON) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      this._advance();\n      const strNum = this._input.substring(numberStart, this._index - 1);\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch (e) {\n        const entity = this._input.substring(start.offset + 1, this._index - 1);\n        throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n      }\n    } else {\n      const startPosition = this._savePosition();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._peek != chars.$SEMICOLON) {\n        this._restorePosition(startPosition);\n        return '&';\n      }\n      this._advance();\n      const name = this._input.substring(start.offset + 1, this._index - 1);\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(\n      decodeEntities: boolean, firstCharOfEnd: number, attemptEndRest: () => boolean): Token {\n    let tagCloseStart: ParseLocation;\n    const textStart = this._getLocation();\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);\n    const parts: string[] = [];\n    while (true) {\n      tagCloseStart = this._getLocation();\n      if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n        break;\n      }\n      if (this._index > tagCloseStart.offset) {\n        // add the characters consumed by the previous if statement to the output\n        parts.push(this._input.substring(tagCloseStart.offset, this._index));\n      }\n      while (this._peek !== firstCharOfEnd) {\n        parts.push(this._readChar(decodeEntities));\n      }\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n  }\n\n  private _consumeComment(start: ParseLocation) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$MINUS, () => this._attemptStr('->'));\n    this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: ParseLocation) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$RBRACKET, () => this._attemptStr(']>'));\n    this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: ParseLocation) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    this._attemptUntilChar(chars.$GT);\n    this._advance();\n    this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._index;\n    let prefix: string = null !;\n    while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {\n      this._advance();\n    }\n    let nameStart: number;\n    if (this._peek === chars.$COLON) {\n      this._advance();\n      prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n      nameStart = this._index;\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n    const name = this._input.substring(nameStart, this._index);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: ParseLocation) {\n    const savedPos = this._savePosition();\n    let tagName: string;\n    let lowercaseTagName: string;\n    try {\n      if (!chars.isAsciiLetter(this._peek)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      const nameStart = this._index;\n      this._consumeTagOpenStart(start);\n      tagName = this._input.substring(nameStart, this._index);\n      lowercaseTagName = tagName.toLowerCase();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof _ControlFlowError) {\n        // When the start tag is invalid, assume we want a \"<\"\n        this._restorePosition(savedPos);\n        // Back to back text tokens are merged at the end\n        this._beginToken(TokenType.TEXT, start);\n        this._endToken(['<']);\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).contentType;\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(lowercaseTagName: string, decodeEntities: boolean) {\n    const textToken = this._consumeRawText(decodeEntities, chars.$LT, () => {\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(lowercaseTagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);\n    this._endToken([null !, lowercaseTagName]);\n  }\n\n  private _consumeTagOpenStart(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    this._beginToken(TokenType.ATTR_VALUE);\n    let value: string;\n    if (this._peek === chars.$SQ || this._peek === chars.$DQ) {\n      const quoteChar = this._peek;\n      this._advance();\n      const parts: string[] = [];\n      while (this._peek !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join('');\n      this._advance();\n    } else {\n      const valueStart = this._index;\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._input.substring(valueStart, this._index);\n    }\n    this._endToken([this._processCarriageReturns(value)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType =\n        this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const condition = this._readUntil(chars.$COMMA);\n    this._endToken([condition], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._getLocation();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n          this._interpolationConfig && this._inInterpolation &&\n          this._attemptStr(this._interpolationConfig.end)) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._peek === chars.$LT || this._peek === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _savePosition(): [number, number, number, number, number] {\n    return [this._peek, this._index, this._column, this._line, this.tokens.length];\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._index;\n    this._attemptUntilChar(char);\n    return this._input.substring(start, this._index);\n  }\n\n  private _restorePosition(position: [number, number, number, number, number]): void {\n    this._peek = position[0];\n    this._index = position[1];\n    this._column = position[2];\n    this._line = position[3];\n    const nbTokens = position[4];\n    if (nbTokens < this.tokens.length) {\n      // remove any extra tokens\n      this.tokens = this.tokens.slice(0, nbTokens);\n    }\n  }\n\n  private _isInExpansionCase(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START;\n  }\n\n  private _isInExpansionForm(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$SLASH ||\n      code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n      (code < chars.$0 || code > chars.$9);\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionFormStart(\n    input: string, offset: number, interpolationConfig: InterpolationConfig): boolean {\n  const isInterpolationStart =\n      interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n\n  return input.charCodeAt(offset) == chars.$LBRACE && !isInterpolationStart;\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token|undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n"]}